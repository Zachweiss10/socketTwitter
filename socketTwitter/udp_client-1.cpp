
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

struct header {

    char magic1;
    char magic2;
    char opcode;
    char payload_len;

    uint32_t token;
    uint32_t msg_id;
};

const int h_size = sizeof(struct header);

// These are the constants indicating the states.
#define STATE_OFFLINE          0
#define STATE_LOGIN_SENT       1
#define STATE_ONLINE           2
// Now you can define other states in a similar fashion.

// These are the constants indicating the events.
// All events starting with EVENT_USER_ are generated by a human user.
#define EVENT_USER_LOGIN               0
#define EVENT_USER_POST                1
// Now you can define other events from the user.
#define EVENT_USER_INVALID             79

// All events starting with EVENT_NET_ are generated by receiving a msg
// from the network. We deliberately use larger numbers to help debug.
#define EVENT_NET_LOGIN_SUCCESSFUL      80
#define EVENT_NET_POST_ACK              81
#define EVENT_NET_SUBSCRIBE_SUCCESS     82
#define EVENT_NET_SUBSCRIBE_FAIL        83
#define EVENT_NET_UNSUBSCRIBE_SUCCESS   84
#define EVENT_NET_UNSUBSCRIBE_FAIL      85
#define EVENT_NET_RETRIEVE_SUCCESS      86
#define EVENT_NET_END_OF_RETRIEVE       87
#define EVENT_NET_LOGOUT                88
#define EVENT_NET_LOGIN_FAILED          89
#define EVENT_NET_PUSH                  91
#define EVENT_SESSION_RESET             93
#define EVENT_SERVER_RESET              95
#define EVENT_USER_RESET2               94
// Now you can define other events from the network.
#define EVENT_NET_FORWARD               90
#define EVENT_PUSHED                    92
#define EVENT_NET_INVALID               255

#define EVENT_USER_RESET                254
#define EVENT_USER_RETRIEVE             253
#define EVENT_USER_SUBSCRIBED           252
#define EVENT_USER_LOGOUT               251
#define EVENT_USER_UNSUBSCRIBE          250

// These are the constants indicating the opcodes.
#define OPCODE_RESET                    0x00
#define OPCODE_RESET2                   0x01
#define OPCODE_MUST_LOGIN_FIRST_ERROR   0xF0
#define OPCODE_LOGIN                    0x10
// Now you can define other opcodes in a similar fashion.
/*New OPCODES*/
#define MAGIC_1 0x5A
#define MAGIC_2 0x57
#define session_reset 0x00
#define server_reset  0x02
#define must_login_first_error 0xF0
#define login 0x10
#define successful_login_ack 0x80
#define failed_login_ack 0x11
#define subscribe 0x20
#define successful_subscribe_ack 0x90
#define failed_subscribe_ack 0x91
#define unsubscribe 0x21
#define successful_unsubscribe_ack 0xA0
#define failed_unsubscribe_ack 0xA1
#define post 0x30
#define post_ack 0xB0
#define forward 0xB1
#define forward_ack 0x31
#define retrieve 0x40
#define retrieve_ack 0xC0
#define end_of_retrieve_ack 0xC1
#define logout 0x1F
#define logout_ack 0x8f
#define net_push 0xb1
#define push_ack 0xb2

union opcode{
    unsigned char byte;
    int integer;
};

using namespace std;

int event;

int parse_the_event_from_the_received_message(unsigned char recv_buffer){
        //printf("%x\n",recv_buffer );
        if(recv_buffer == post_ack)
            event=EVENT_NET_POST_ACK;
        else if(recv_buffer == successful_login_ack)
            event = EVENT_NET_LOGIN_SUCCESSFUL;
        else if(recv_buffer == failed_login_ack)
            event = EVENT_NET_LOGIN_FAILED;
        else if(recv_buffer == successful_subscribe_ack)
            event = EVENT_NET_SUBSCRIBE_SUCCESS;
        else if(recv_buffer == failed_subscribe_ack)
            event = EVENT_NET_SUBSCRIBE_FAIL;
        else if(recv_buffer == successful_unsubscribe_ack)
            event = EVENT_NET_UNSUBSCRIBE_SUCCESS;
        else if(recv_buffer == failed_unsubscribe_ack)
            event = EVENT_NET_UNSUBSCRIBE_FAIL;
        else if(recv_buffer == retrieve_ack)
            event = EVENT_NET_RETRIEVE_SUCCESS;
        else if(recv_buffer == end_of_retrieve_ack)
            event = EVENT_NET_END_OF_RETRIEVE;
        else if(recv_buffer == logout_ack)
            event = EVENT_NET_LOGOUT;
        else if(recv_buffer == forward_ack)
            event = EVENT_NET_FORWARD;
        else if(recv_buffer == net_push)
            event = EVENT_NET_PUSH;
        else if (recv_buffer == push_ack)
            event = EVENT_PUSHED;
        else if (recv_buffer == session_reset)
            event = EVENT_SESSION_RESET;
        else if (recv_buffer == server_reset)
            event = EVENT_SERVER_RESET;
        else
            event = EVENT_NET_INVALID;

        return event;
}

int parse_the_event_from_the_input_string(char * user_input){
    char * str;
    int i=0;
    while(user_input[i]!='#')
    {
        str[i]=user_input[i];
        i++;
    }
    str[i]= '\0';
    if(!strcmp(str,"retrieve")){
        event=EVENT_USER_RETRIEVE;
    }
    else if(!strcmp(str,"post")){
        event = EVENT_USER_POST;
    }
    else if(!strcmp(str,"login")){
        event = EVENT_USER_LOGIN;
    }
    else if(!strcmp(str, "logout")){
        event = EVENT_USER_LOGOUT;
    }
    else if(!strcmp(str, "unsubscribe")){
        event = EVENT_USER_UNSUBSCRIBE;
    }
    else if(!strcmp(str, "subscribe")){
        event = EVENT_USER_SUBSCRIBED;
    }
    else if (!strcmp(str, "spurious")){
        event = EVENT_USER_RESET;
    }
    else if (!strcmp(str, "spurious2")){
        event = EVENT_USER_RESET2;
    }
    else{
        event = -1;
    }

    return event;
}


int main() {

    char user_input[1024];

    int ret;
    int sockfd = 0;
    char send_buffer[1024];
    char recv_buffer[1024];
    struct sockaddr_in serv_addr;
    struct sockaddr_in my_addr;
    int maxfd;
    fd_set read_set;
    FD_ZERO(&read_set);


    // You just need one socket file descriptor. I made a mistake previously
    // and defined two socket file descriptors.
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
	printf("socket() error: %s.\n", strerror(errno));
        return -1;
    }

    // The "serv_addr" is the server's address and port number, 
    // i.e, the destination address if the client needs to send something. 
    // Note that this "serv_addr" must match with the address in the 
    // "UDP receive" code.
    // We assume the server is also running on the same machine, and 
    // hence, the IP address of the server is just "127.0.0.1".
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    serv_addr.sin_port = htons(32000);

    // The "my_addr" is the client's address and port number used for  
    // receiving responses from the server.
    // Note that this is a local address, not a remote address.
    memset(&my_addr, 0, sizeof(my_addr));
    my_addr.sin_family = AF_INET;
    my_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    my_addr.sin_port = htons(32010);


    // Bind "my_addr" to the socket for receiving messages from the server.
    bind(sockfd, 
         (struct sockaddr *) &my_addr, 
         sizeof(my_addr));

    maxfd = sockfd + 1; // Note that the file descriptor of stdin is "0"
    
    int state = STATE_OFFLINE;

    uint32_t token; // Assume the token is a 32-bit integer

    // This is a pointer of the type "struct header" but it always points
    // to the first byte of the "send_buffer", i.e., if we dereference this
    // pointer, we get the first 12 bytes in the "send_buffer" in the format
    // of the structure, which is very convenient.
    struct header *ph_send = (struct header *)send_buffer;
    // So as the receive buffer.
    struct header *ph_recv = (struct header *)recv_buffer;

    while (1) {
        //memset(ph_send,0,sizeof(ph_send));
        //memset(user_input,0, sizeof(user_input));
        //memset(send_buffer,0, sizeof(send_buffer));
        // Use select to wait on keyboard input or socket receiving.
        FD_SET(fileno(stdin), &read_set);
        FD_SET(sockfd, &read_set);

        select(maxfd, &read_set, NULL, NULL, NULL);

        if (FD_ISSET(fileno(stdin), &read_set)) {

            // Now we know there is a keyboard input event
            // TODO: Figure out which event and process it according to the
            // current state

            fgets(user_input, sizeof(user_input), stdin);

            // Note that in this parse function, you need to check the
            // user input and figure out what event it is. Basically it
            // will be a long sequence of if (strncmp(user_input, ...) == 0)
            // and if none of the "if" matches, return EVENT_USER_INVALID
            event = parse_the_event_from_the_input_string(user_input);

            // You can also add a line to print the "event" for debugging.
            //printf("The event from input is: %d\n",event);

		if (event == EVENT_USER_LOGIN) {
            	    if (state == STATE_OFFLINE) {

                    // CAUTION: we do not need to parse the user ID and
                    // and password string, assuming they are always in the
                    // correct format. The server will parse it anyway.

                    char *id_password = user_input + 6; // skip the "login#"
                    int m = strlen(id_password);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_LOGIN;
                    ph_send->payload_len = m;
                    ph_send->token = 0;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, id_password, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    // Once the corresponding action finishes, transit to
                    // the login_sent state
            	        state = STATE_LOGIN_SENT;

                } else {

                    // TODO: handle errors if the event happens in a state
                    // that is not expected. Basically just print an error
                    // message and doing nothing. Note that if a user types
                    // something invalid, it does not need to trigger a 
                    // session reset.
                    printf("You are already logged in\n");

                }

            }else if (event == EVENT_USER_RESET2){
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_RESET2;
                ph_send->payload_len = 0;
                ph_send->token = token;
                ph_send->msg_id = 0;
                sendto(sockfd, send_buffer, h_size, 0,(struct sockaddr *) &serv_addr, sizeof(serv_addr));;
            }else if (event == EVENT_USER_LOGOUT){
                if(state == STATE_ONLINE){

                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = logout;
                ph_send->payload_len = 0;
                ph_send->msg_id = 0;

                sendto(sockfd, send_buffer, h_size, 0, 
                    (struct sockaddr *) &serv_addr, sizeof(serv_addr));
            }

            } 
            else if (event == EVENT_USER_POST) {
                if(state == STATE_ONLINE){

                    // Note that this is similar to the login msg.
                    // Actually, these messages are carefully designed to 
                    // somewhat minimize the processing on the client side.
                    // If you look at the "subscribe", "unsubscribe", "post"
                    // and "retrieve", they are all similar, i.e., just fill
                    // the header and copy the user input after the "#" as
                    // the payload of the message, then just send the msg.

                    char *text = user_input + 5; // skip the "post#"
                    int m = strlen(text);


                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = post;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, text, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));
                }
                else{
                    printf("error#must_login_first\n");
                }


            } else if (event == EVENT_USER_RESET) {

                // TODO: You may add another command like "reset#" so as to
                // facilitate testing. In this case, a user just need to 
                // type this line to generate a reset message.

                // You can add more commands as you like to help debugging.
                // For example, I can add a command "state#" to instruct the
                // client program to print the current state without chang
                // -ing anything.
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_RESET;
                ph_send->payload_len = 0;
                ph_send->token = token;
                ph_send->msg_id = 0;

                sendto(sockfd, send_buffer, h_size, 0, 
                    (struct sockaddr *) &serv_addr, sizeof(serv_addr));



            } else if (event == EVENT_USER_SUBSCRIBED) {
                if(state == STATE_ONLINE){
                // TODO: process other event
                //subscribe#
                char * text = user_input + 10;
                int m = strlen(text);
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = subscribe;
                ph_send->payload_len = m;
                ph_send->token = token;
                ph_send->msg_id = 0;

                memcpy(send_buffer + h_size, text, m);

                sendto(sockfd, send_buffer, h_size + m, 0, 
                    (struct sockaddr *) &serv_addr, sizeof(serv_addr));
                }
                else
                    printf("error#must_login_first\n");

            }
            else if(event == EVENT_USER_UNSUBSCRIBE){
                if(state == STATE_ONLINE){
                // TODO: process other event
                //subscribe#
                char * text = user_input + 12;
                int m = strlen(text);
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = unsubscribe;
                ph_send->payload_len = m;
                ph_send->token = token;
                ph_send->msg_id = 0;

                memcpy(send_buffer + h_size, text, m);

                sendto(sockfd, send_buffer, h_size + m, 0, 
                    (struct sockaddr *) &serv_addr, sizeof(serv_addr));
                }
                else
                    printf("error#must_login_first\n");

            }else if (event == EVENT_USER_RETRIEVE) {
                if(state == STATE_ONLINE){
                // TODO: process other event
                char * text = user_input + 9;
                int m = strlen(text);
                int check = atoi(text);
                    if(check != 0 && check <100){
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = retrieve;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, text, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));
                    }
                    else{
                        printf("Please enter an n {n|0<n<100}\n");

                }

            }
                else
                    printf("error#must_login_first\n");


            }

        }
        if (FD_ISSET(sockfd, &read_set)) {

            // Now we know there is an event from the network
            // TODO: Figure out which event and process it according to the
            // current state

            
            ret = recv(sockfd, recv_buffer, sizeof(recv_buffer), 0);
            

            event = parse_the_event_from_the_received_message(recv_buffer[2]);
            //printf("event is: %d\n",event );

            if (event == EVENT_NET_LOGIN_SUCCESSFUL) {
            	    if (state == STATE_LOGIN_SENT) {

                    token = ph_recv->token;
                    printf("login_ack#successful\n");
                    // TODO: print a line of "login_ack#successful"
                    state = STATE_ONLINE;

                } else {

                    // A spurious msg is received. Just reset the session.
                    // You can define a function "send_reset()" for 
                    // convenience because it might be used in many places.
                    /*send_reset() below*/
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_RESET;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_OFFLINE;
                }
            } else if (event == EVENT_NET_LOGIN_FAILED) {
            	    if (state == STATE_LOGIN_SENT) {
                    printf("login_ack#failed\n");
                    // TODO: print a line of "login_ack#failed"
                    state = STATE_OFFLINE;

                } else {

                    /*SEND RESET*/
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_RESET;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, 
                        (struct sockaddr *) &serv_addr, sizeof(serv_addr));




                    state = STATE_OFFLINE;
                }

            } else if (event == EVENT_NET_POST_ACK) {

                // TODO: Process other events.
                //printf("token is %u\n",token );
                printf("post_ack#successful\n");
                state = STATE_ONLINE;

            }
            else if (event == EVENT_NET_FORWARD) {

                // TODO: Process other events.
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = forward_ack;
                ph_send->payload_len = 0;
                ph_send->token = token;
                ph_send->msg_id = 0;
                sendto(sockfd, send_buffer, h_size, 0, 
                (struct sockaddr *) &serv_addr, sizeof(serv_addr));
                state = STATE_ONLINE;

            }else if(event == EVENT_PUSHED){
                printf("push_ack\n");
            }
            else if (event == EVENT_NET_SUBSCRIBE_FAIL) {

                // TODO: Process other events.
                printf("subscribe_ack#failed\n");
                state = STATE_ONLINE;

            }else if (event == EVENT_NET_SUBSCRIBE_SUCCESS) {

                printf("subscribe_ack#successful\n");
                // TODO: Process other events.
                state = STATE_ONLINE;

            }else if (event == EVENT_NET_UNSUBSCRIBE_SUCCESS) {

                // TODO: Process other events.
                printf("unsubscribe_ack#successful\n");
                state = STATE_ONLINE;

            }else if (event == EVENT_NET_UNSUBSCRIBE_FAIL) {

                // TODO: Process other events.
                printf("unsubscribe_ack#failed\n");
                state = STATE_ONLINE;

            }else if (event == EVENT_NET_RETRIEVE_SUCCESS) {
                
                

                socklen_t len = sizeof(serv_addr);
                int recv_len = recvfrom(sockfd, // socket file descriptor
                 recv_buffer,       // receive buffer
                 sizeof(recv_buffer),  // number of bytes to be received
                 0,
                 (struct sockaddr *) &serv_addr,  // client address
                 &len);

                char text[ph_recv->payload_len];
                strcpy(text, recv_buffer+h_size);
                text[ph_recv->payload_len]= '\0';
                printf("%s\n",text);


                

                /*strcpy(text, recv_buffer+h_size);
                text[ph_recv->payload_len]= '\0';
                printf("text is: %s\n",text);*/

                // TODO: Process other events.
            }
            else if (event == EVENT_NET_END_OF_RETRIEVE) {

                /*socklen_t len = sizeof(serv_addr);
                int recv_len = recvfrom(sockfd, // socket file descriptor
                 recv_buffer,       // receive buffer
                 sizeof(recv_buffer),  // number of bytes to be received
                 0,
                 (struct sockaddr *) &serv_addr,  // client address
                 &len);*/ 

                char text[ph_recv->payload_len];
                strcpy(text, recv_buffer+h_size);
                //text[ph_recv->payload_len]= '\0';
                printf("%s\n",text);
                printf("end_of_retrieve_ack\n");

                // TODO: Process other events.
                state = STATE_ONLINE;
            }else if (event == EVENT_NET_LOGOUT) {
            if( state == STATE_ONLINE){
                printf("logout_ack#successful\n");
                // TODO: Process other events.
                state = STATE_OFFLINE;
            }
            }
            else if (event == EVENT_NET_LOGIN_FAILED) {

                printf("unsuccessful logout\n");
                // TODO: Process other events.
                state = STATE_ONLINE;
            }
            else if (event == EVENT_NET_PUSH){

                char * text2 = recv_buffer + h_size;
                char text[ph_recv->payload_len];
                strcpy(text, text2);
                text[ph_recv->payload_len]= '\0';
                printf("(Push): %s",text);
            }
            else if (event ==EVENT_SESSION_RESET){
                printf("reset_ack\n");
                state = STATE_OFFLINE;
            }
            else if (event ==EVENT_SERVER_RESET){
                printf("server_reset_ack\n");
                state = STATE_OFFLINE;
            }
            
            else{
                printf("The client received an invalid opcode!\n");
                state = STATE_ONLINE;
            }






        }

        // Now we finished processing the pending event. Just go back to the
        // beginning of the loop and waiting for another event. 
        // Note that you can set a timeout for the select() function 
        // to allow it to return regularly and check timeout related events.

    } // This is the end of the while loop

} // This is the end of main()

